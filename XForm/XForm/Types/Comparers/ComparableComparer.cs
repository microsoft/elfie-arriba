// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;

using XForm.Data;
using XForm.Query;

namespace XForm.Types.Comparers
{
    /// <summary>
    ///  IXArrayComparer for T[].
    ///  GENERATED by XForm.Generator\ComparerGenerator.cs
    /// </summary>
    internal class ComparableComparer<T> : IXArrayComparer, IXArrayComparer<T> where T : System.IComparable<T>
    {
        internal static ComparerExtensions.WhereSingle<T> s_WhereSingleNative = null;
        internal static ComparerExtensions.Where<T> s_WhereNative = null;

        public void GetHashCodes(XArray xarray, int[] hashes)
        {
            if (hashes.Length < xarray.Count) throw new ArgumentOutOfRangeException("hashes.Length");
            T[] array = (T[])xarray.Array;

            for (int i = 0; i < xarray.Count; ++i)
            {
                int index = xarray.Index(i);
                if (!xarray.HasNulls || xarray.NullRows[index] == false)
                {
                    hashes[i] = (hashes[i] << 5) - hashes[i] + unchecked((int)Hashing.Hash(array[xarray.Index(i)].GetHashCode(), 0));
                }
            }
        }

        public int GetHashCode(T value)
        {
            return unchecked((int)Hashing.Hash(value.GetHashCode(), 0));
        }

        public void WhereEqual(XArray left, XArray right, BitVector vector)
        {
            T[] leftArray = (T[])left.Array;
            T[] rightArray = (T[])right.Array;

            // Check how the XArrays are configured and run the fastest loop possible for the configuration.
            if (left.Selector.Indices != null || right.Selector.Indices != null)
            {
                // Slow Path: Look up indices on both sides. ~55ms for 16M
                for (int i = 0; i < left.Count; ++i)
                {
                    if (leftArray[left.Index(i)].CompareTo(rightArray[right.Index(i)]) == 0) vector.Set(i);
                }
            }
            else if (!right.Selector.IsSingleValue)
            {
                // Faster Path: Compare contiguous arrays. ~20ms for 16M
                if (s_WhereNative != null)
                {
                    s_WhereNative(leftArray, left.Selector.StartIndexInclusive, (byte)CompareOperator.Equal, rightArray, right.Selector.StartIndexInclusive, left.Selector.Count, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    int zeroOffset = left.Selector.StartIndexInclusive;
                    int leftIndexToRightIndex = right.Selector.StartIndexInclusive - left.Selector.StartIndexInclusive;
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightArray[i + leftIndexToRightIndex]) == 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else if (!left.Selector.IsSingleValue)
            {
                // Fastest Path: Contiguous Array to constant. ~15ms for 16M
                int zeroOffset = left.Selector.StartIndexInclusive;
                T rightValue = rightArray[0];

                if (s_WhereSingleNative != null)
                {
                    s_WhereSingleNative(leftArray, left.Selector.StartIndexInclusive, left.Selector.Count, (byte)CompareOperator.Equal, rightValue, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightValue) == 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else
            {
                // Single Static comparison. ~0.7ms for 16M [called every 10,240 rows]
                if (leftArray[left.Selector.StartIndexInclusive].CompareTo(rightArray[right.Selector.StartIndexInclusive]) == 0)
                {
                    vector.All(left.Count);
                }
            }

            // Remove nulls from matches
            BoolComparer.AndNotNull(left, vector);
            BoolComparer.AndNotNull(right, vector);
        }

        public bool WhereEqual(T left, T right)
        {
            return left.CompareTo(right) == 0;
        }

        public void WhereNotEqual(XArray left, XArray right, BitVector vector)
        {
            T[] leftArray = (T[])left.Array;
            T[] rightArray = (T[])right.Array;

            // Check how the XArrays are configured and run the fastest loop possible for the configuration.
            if (left.Selector.Indices != null || right.Selector.Indices != null)
            {
                // Slow Path: Look up indices on both sides. ~55ms for 16M
                for (int i = 0; i < left.Count; ++i)
                {
                    if (leftArray[left.Index(i)].CompareTo(rightArray[right.Index(i)]) != 0) vector.Set(i);
                }
            }
            else if (!right.Selector.IsSingleValue)
            {
                // Faster Path: Compare contiguous arrays. ~20ms for 16M
                if (s_WhereNative != null)
                {
                    s_WhereNative(leftArray, left.Selector.StartIndexInclusive, (byte)CompareOperator.NotEqual, rightArray, right.Selector.StartIndexInclusive, left.Selector.Count, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    int zeroOffset = left.Selector.StartIndexInclusive;
                    int leftIndexToRightIndex = right.Selector.StartIndexInclusive - left.Selector.StartIndexInclusive;
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightArray[i + leftIndexToRightIndex]) != 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else if (!left.Selector.IsSingleValue)
            {
                // Fastest Path: Contiguous Array to constant. ~15ms for 16M
                int zeroOffset = left.Selector.StartIndexInclusive;
                T rightValue = rightArray[0];

                if (s_WhereSingleNative != null)
                {
                    s_WhereSingleNative(leftArray, left.Selector.StartIndexInclusive, left.Selector.Count, (byte)CompareOperator.NotEqual, rightValue, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightValue) != 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else
            {
                // Single Static comparison. ~0.7ms for 16M [called every 10,240 rows]
                if (leftArray[left.Selector.StartIndexInclusive].CompareTo(rightArray[right.Selector.StartIndexInclusive]) != 0)
                {
                    vector.All(left.Count);
                }
            }

            // Remove nulls from matches
            BoolComparer.AndNotNull(left, vector);
            BoolComparer.AndNotNull(right, vector);
        }

        public bool WhereNotEqual(T left, T right)
        {
            return left.CompareTo(right) != 0;
        }

        public void WhereLessThan(XArray left, XArray right, BitVector vector)
        {
            T[] leftArray = (T[])left.Array;
            T[] rightArray = (T[])right.Array;

            // Check how the XArrays are configured and run the fastest loop possible for the configuration.
            if (left.Selector.Indices != null || right.Selector.Indices != null)
            {
                // Slow Path: Look up indices on both sides. ~55ms for 16M
                for (int i = 0; i < left.Count; ++i)
                {
                    if (leftArray[left.Index(i)].CompareTo(rightArray[right.Index(i)]) < 0) vector.Set(i);
                }
            }
            else if (!right.Selector.IsSingleValue)
            {
                // Faster Path: Compare contiguous arrays. ~20ms for 16M
                if (s_WhereNative != null)
                {
                    s_WhereNative(leftArray, left.Selector.StartIndexInclusive, (byte)CompareOperator.LessThan, rightArray, right.Selector.StartIndexInclusive, left.Selector.Count, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    int zeroOffset = left.Selector.StartIndexInclusive;
                    int leftIndexToRightIndex = right.Selector.StartIndexInclusive - left.Selector.StartIndexInclusive;
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightArray[i + leftIndexToRightIndex]) < 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else if (!left.Selector.IsSingleValue)
            {
                // Fastest Path: Contiguous Array to constant. ~15ms for 16M
                int zeroOffset = left.Selector.StartIndexInclusive;
                T rightValue = rightArray[0];

                if (s_WhereSingleNative != null)
                {
                    s_WhereSingleNative(leftArray, left.Selector.StartIndexInclusive, left.Selector.Count, (byte)CompareOperator.LessThan, rightValue, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightValue) < 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else
            {
                // Single Static comparison. ~0.7ms for 16M [called every 10,240 rows]
                if (leftArray[left.Selector.StartIndexInclusive].CompareTo(rightArray[right.Selector.StartIndexInclusive]) < 0)
                {
                    vector.All(left.Count);
                }
            }

            // Remove nulls from matches
            BoolComparer.AndNotNull(left, vector);
            BoolComparer.AndNotNull(right, vector);
        }

        public bool WhereLessThan(T left, T right)
        {
            return left.CompareTo(right) < 0;
        }

        public void WhereLessThanOrEqual(XArray left, XArray right, BitVector vector)
        {
            T[] leftArray = (T[])left.Array;
            T[] rightArray = (T[])right.Array;

            // Check how the XArrays are configured and run the fastest loop possible for the configuration.
            if (left.Selector.Indices != null || right.Selector.Indices != null)
            {
                // Slow Path: Look up indices on both sides. ~55ms for 16M
                for (int i = 0; i < left.Count; ++i)
                {
                    if (leftArray[left.Index(i)].CompareTo(rightArray[right.Index(i)]) <= 0) vector.Set(i);
                }
            }
            else if (!right.Selector.IsSingleValue)
            {
                // Faster Path: Compare contiguous arrays. ~20ms for 16M
                if (s_WhereNative != null)
                {
                    s_WhereNative(leftArray, left.Selector.StartIndexInclusive, (byte)CompareOperator.LessThanOrEqual, rightArray, right.Selector.StartIndexInclusive, left.Selector.Count, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    int zeroOffset = left.Selector.StartIndexInclusive;
                    int leftIndexToRightIndex = right.Selector.StartIndexInclusive - left.Selector.StartIndexInclusive;
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightArray[i + leftIndexToRightIndex]) <= 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else if (!left.Selector.IsSingleValue)
            {
                // Fastest Path: Contiguous Array to constant. ~15ms for 16M
                int zeroOffset = left.Selector.StartIndexInclusive;
                T rightValue = rightArray[0];

                if (s_WhereSingleNative != null)
                {
                    s_WhereSingleNative(leftArray, left.Selector.StartIndexInclusive, left.Selector.Count, (byte)CompareOperator.LessThanOrEqual, rightValue, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightValue) <= 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else
            {
                // Single Static comparison. ~0.7ms for 16M [called every 10,240 rows]
                if (leftArray[left.Selector.StartIndexInclusive].CompareTo(rightArray[right.Selector.StartIndexInclusive]) <= 0)
                {
                    vector.All(left.Count);
                }
            }

            // Remove nulls from matches
            BoolComparer.AndNotNull(left, vector);
            BoolComparer.AndNotNull(right, vector);
        }

        public bool WhereLessThanOrEqual(T left, T right)
        {
            return left.CompareTo(right) <= 0;
        }

        public void WhereGreaterThan(XArray left, XArray right, BitVector vector)
        {
            T[] leftArray = (T[])left.Array;
            T[] rightArray = (T[])right.Array;

            // Check how the XArrays are configured and run the fastest loop possible for the configuration.
            if (left.Selector.Indices != null || right.Selector.Indices != null)
            {
                // Slow Path: Look up indices on both sides. ~55ms for 16M
                for (int i = 0; i < left.Count; ++i)
                {
                    if (leftArray[left.Index(i)].CompareTo(rightArray[right.Index(i)]) > 0) vector.Set(i);
                }
            }
            else if (!right.Selector.IsSingleValue)
            {
                // Faster Path: Compare contiguous arrays. ~20ms for 16M
                if (s_WhereNative != null)
                {
                    s_WhereNative(leftArray, left.Selector.StartIndexInclusive, (byte)CompareOperator.GreaterThan, rightArray, right.Selector.StartIndexInclusive, left.Selector.Count, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    int zeroOffset = left.Selector.StartIndexInclusive;
                    int leftIndexToRightIndex = right.Selector.StartIndexInclusive - left.Selector.StartIndexInclusive;
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightArray[i + leftIndexToRightIndex]) > 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else if (!left.Selector.IsSingleValue)
            {
                // Fastest Path: Contiguous Array to constant. ~15ms for 16M
                int zeroOffset = left.Selector.StartIndexInclusive;
                T rightValue = rightArray[0];

                if (s_WhereSingleNative != null)
                {
                    s_WhereSingleNative(leftArray, left.Selector.StartIndexInclusive, left.Selector.Count, (byte)CompareOperator.GreaterThan, rightValue, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightValue) > 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else
            {
                // Single Static comparison. ~0.7ms for 16M [called every 10,240 rows]
                if (leftArray[left.Selector.StartIndexInclusive].CompareTo(rightArray[right.Selector.StartIndexInclusive]) > 0)
                {
                    vector.All(left.Count);
                }
            }

            // Remove nulls from matches
            BoolComparer.AndNotNull(left, vector);
            BoolComparer.AndNotNull(right, vector);
        }

        public bool WhereGreaterThan(T left, T right)
        {
            return left.CompareTo(right) > 0;
        }

        public void WhereGreaterThanOrEqual(XArray left, XArray right, BitVector vector)
        {
            T[] leftArray = (T[])left.Array;
            T[] rightArray = (T[])right.Array;

            // Check how the XArrays are configured and run the fastest loop possible for the configuration.
            if (left.Selector.Indices != null || right.Selector.Indices != null)
            {
                // Slow Path: Look up indices on both sides. ~55ms for 16M
                for (int i = 0; i < left.Count; ++i)
                {
                    if (leftArray[left.Index(i)].CompareTo(rightArray[right.Index(i)]) >= 0) vector.Set(i);
                }
            }
            else if (!right.Selector.IsSingleValue)
            {
                // Faster Path: Compare contiguous arrays. ~20ms for 16M
                if (s_WhereNative != null)
                {
                    s_WhereNative(leftArray, left.Selector.StartIndexInclusive, (byte)CompareOperator.GreaterThanOrEqual, rightArray, right.Selector.StartIndexInclusive, left.Selector.Count, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    int zeroOffset = left.Selector.StartIndexInclusive;
                    int leftIndexToRightIndex = right.Selector.StartIndexInclusive - left.Selector.StartIndexInclusive;
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightArray[i + leftIndexToRightIndex]) >= 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else if (!left.Selector.IsSingleValue)
            {
                // Fastest Path: Contiguous Array to constant. ~15ms for 16M
                int zeroOffset = left.Selector.StartIndexInclusive;
                T rightValue = rightArray[0];

                if (s_WhereSingleNative != null)
                {
                    s_WhereSingleNative(leftArray, left.Selector.StartIndexInclusive, left.Selector.Count, (byte)CompareOperator.GreaterThanOrEqual, rightValue, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i].CompareTo(rightValue) >= 0) vector.Set(i - zeroOffset);
                    }
                }
            }
            else
            {
                // Single Static comparison. ~0.7ms for 16M [called every 10,240 rows]
                if (leftArray[left.Selector.StartIndexInclusive].CompareTo(rightArray[right.Selector.StartIndexInclusive]) >= 0)
                {
                    vector.All(left.Count);
                }
            }

            // Remove nulls from matches
            BoolComparer.AndNotNull(left, vector);
            BoolComparer.AndNotNull(right, vector);
        }

        public bool WhereGreaterThanOrEqual(T left, T right)
        {
            return left.CompareTo(right) >= 0;
        }
    }
}
