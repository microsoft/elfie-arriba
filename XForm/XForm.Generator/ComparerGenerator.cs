// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.IO;
using System.Text.RegularExpressions;

namespace XForm.Generator
{
    public static class ComparerGenerator
    {
        private static string s_filePrefix = @"// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;

using XForm.Data;
using XForm.Query;

namespace XForm.Types.Comparers
{
    /// <summary>
    ///  IXArrayComparer for long[].
    ///  GENERATED by XForm.Generator\ComparerGenerator.cs
    /// </summary>
    internal class LongComparer : IXArrayComparer, IXArrayComparer<long>
    {
        internal static ComparerExtensions.WhereSingle<long> s_WhereSingleNative = null;
        internal static ComparerExtensions.Where<long> s_WhereNative = null;

        public void GetHashCodes(XArray xarray, int[] hashes)
        {
            if (hashes.Length < xarray.Count) throw new ArgumentOutOfRangeException(""hashes.Length"");
            long[] array = (long[])xarray.Array;

            for (int i = 0; i < xarray.Count; ++i)
            {
                int index = xarray.Index(i);
                if (!xarray.HasNulls || xarray.NullRows[index] == false)
                {
                    hashes[i] = (hashes[i] << 5) - hashes[i] + unchecked((int)Hashing.Hash(array[xarray.Index(i)], 0));
                }
            }
        }

        public int GetHashCode(long value)
        {
            return unchecked((int)Hashing.Hash(value, 0));
        }
";

        private static string s_fileSuffix = @"    }
}
";

        // NOTE: Edit this in the 'long[]' copy and then copy and paste the code here once tested
        private static string s_compareMethodTemplate = @"
        public void WhereEqual(XArray left, XArray right, BitVector vector)
        {
            long[] leftArray = (long[])left.Array;
            long[] rightArray = (long[])right.Array;

            // Check how the XArrays are configured and run the fastest loop possible for the configuration.
            if (left.Selector.Indices != null || right.Selector.Indices != null)
            {
                // Slow Path: Look up indices on both sides. ~55ms for 16M
                for (int i = 0; i < left.Count; ++i)
                {
                    if (leftArray[left.Index(i)] == rightArray[right.Index(i)]) vector.Set(i);
                }
            }
            else if (!right.Selector.IsSingleValue)
            {
                // Faster Path: Compare contiguous arrays. ~20ms for 16M
                if (s_WhereNative != null)
                {
                    s_WhereNative(leftArray, left.Selector.StartIndexInclusive, (byte)CompareOperator.Equal, rightArray, right.Selector.StartIndexInclusive, left.Selector.Count, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    int zeroOffset = left.Selector.StartIndexInclusive;
                    int leftIndexToRightIndex = right.Selector.StartIndexInclusive - left.Selector.StartIndexInclusive;
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i] == rightArray[i + leftIndexToRightIndex]) vector.Set(i - zeroOffset);
                    }
                }
            }
            else if (!left.Selector.IsSingleValue)
            {
                // Fastest Path: Contiguous Array to constant. ~15ms for 16M
                int zeroOffset = left.Selector.StartIndexInclusive;
                long rightValue = rightArray[0];

                if (s_WhereSingleNative != null)
                {
                    s_WhereSingleNative(leftArray, left.Selector.StartIndexInclusive, left.Selector.Count, (byte)CompareOperator.Equal, rightValue, (byte)BooleanOperator.Or, vector.Array, 0);
                }
                else
                {
                    for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                    {
                        if (leftArray[i] == rightValue) vector.Set(i - zeroOffset);
                    }
                }
            }
            else
            {
                // Single Static comparison. ~0.7ms for 16M [called every 10,240 rows]
                if (leftArray[left.Selector.StartIndexInclusive] == rightArray[right.Selector.StartIndexInclusive])
                {
                    vector.All(left.Count);
                }
            }

            // Remove nulls from matches
            BoolComparer.AndNotNull(left, vector);
            BoolComparer.AndNotNull(right, vector);
        }

        public bool WhereEqual(long left, long right)
        {
            return left == right;
        }
";

        public static void GenerateAll(string outputPath)
        {
            Directory.CreateDirectory(outputPath);

            foreach (string type in SupportedTypes.PrimitiveTypes)
            {
                Generate(type, outputPath);
            }

            foreach (string type in SupportedTypes.AdditionalTypes)
            {
                // Don't generate String8Comparer for now - ContainsBlock logic.
                if (type.Equals("String8")) continue;

                Generate(type, outputPath);
            }

            Generate("T", outputPath);
        }

        public static void Generate(string typeName, string outputPath)
        {
            string className = (typeName == "T" ? "ComparableComparer" : SupportedTypes.ToClassName(typeName) + "Comparer");

            using (var writer = new StreamWriter(File.Open(Path.Combine(outputPath, $"{className}.cs"), FileMode.Create)))
            {
                string prefix = s_filePrefix
                    .Replace("long", typeName)
                    .Replace("LongComparer", className);

                // Differences for ComparableComparer
                if (typeName == "T")
                {
                    prefix = prefix
                        .Replace("ComparableComparer", "ComparableComparer<T>")
                        .Replace("IXArrayComparer<T>", "IXArrayComparer<T> where T : System.IComparable<T>")
                        .Replace(", 0));", ".GetHashCode(), 0));");  // Get the generic hash code and re-hash it
                }

                // Differences for String8Comparer
                if (typeName == "String8")
                {
                    prefix = prefix
                        .Replace("using System;", "using System;\r\n\r\nusing Microsoft.CodeAnalysis.Elfie.Model.Strings;")
                        .Replace("IXArrayComparer<String8>", "IXArrayTextComparer, IXArrayComparer<String8>");
                }

                writer.Write(prefix);

                WriteMethod(writer, typeName, "Equal", "==");
                WriteMethod(writer, typeName, "NotEqual", "!=");
                WriteMethod(writer, typeName, "LessThan", "<");
                WriteMethod(writer, typeName, "LessThanOrEqual", "<=");
                WriteMethod(writer, typeName, "GreaterThan", ">");
                WriteMethod(writer, typeName, "GreaterThanOrEqual", ">=");

                if (typeName == "String8")
                {
                    WriteMethod(writer, typeName, "Contains", "");
                    WriteMethod(writer, typeName, "ContainsExact", "");
                    WriteMethod(writer, typeName, "StartsWith", "");
                }

                writer.Write(s_fileSuffix);
            }
        }

        private static void WriteMethod(StreamWriter writer, string typeName, string operatorName, string operatorCode)
        {
            string methodBody;

            if (typeName == "T" || typeName == "String8")
            {
                methodBody = s_compareMethodTemplate
                    .Replace("long", typeName)
                    .Replace("Equal", operatorName);

                string replacement = ".CompareTo(${right}) " + operatorCode + " 0";
                if (operatorCode == "")
                {
                    switch (operatorName)
                    {
                        case "Contains":
                            replacement = ".Contains(${right}) != -1";
                            break;
                        case "ContainsExact":
                            replacement = ".Contains(${right}) != -1";
                            break;
                        case "StartsWith":
                            replacement = ".StartsWith(${right}, true)";
                            break;
                        default:
                            throw new NotImplementedException();
                    }
                }

                methodBody = Regex.Replace(methodBody, " == (?<right>(rightValue|rightArray\\[[^\\]]+\\]|right))", replacement);
            }
            else
            {
                methodBody = s_compareMethodTemplate
                    .Replace("long", typeName)
                    .Replace("Equal", operatorName)
                    .Replace("==", operatorCode);
            }

            writer.Write(methodBody);
        }
    }
}