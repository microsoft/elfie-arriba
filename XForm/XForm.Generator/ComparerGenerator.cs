using System;
using System.IO;
using System.Text.RegularExpressions;

namespace XForm.Types.Comparers
{
    public static class ComparerGenerator
    {
        private static string FilePrefix = @"
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using XForm.Data;
using XForm.Query;
using XForm.Transforms;

namespace XForm.Types.Comparers
{
    /// <summary>
    ///  IDataBatchComparer for long[].
    ///  NOTE: Comparers are generated by 'XForm generateComparers'; see ComparerGenerator.cs
    /// </summary>
    internal class LongComparer : IDataBatchComparer
    {
        internal static ComparerExtensions.WhereSingle<long> s_WhereSingleNative = null;
        internal static ComparerExtensions.Where<long> s_WhereNative = null;
";

        private static string FileSuffix = @"
    }
}
";

        // NOTE: Edit this in the 'long[]' copy and then copy and paste the code here once tested
        private static string CompareMethodTemplate = @"
		public void WhereEqual(DataBatch left, DataBatch right, RowRemapper result)
        {
            result.ClearAndSize(left.Count);
            long[] leftArray = (long[])left.Array;
            long[] rightArray = (long[])right.Array;

            // Check how the DataBatches are configured and run the fastest loop possible for the configuration.
            if (left.IsNull != null || right.IsNull != null)
            {
                // Slowest Path: Null checks and look up indices on both sides. ~65ms for 16M
                for (int i = 0; i < left.Count; ++i)
                {
                    int leftIndex = left.Index(i);
                    int rightIndex = right.Index(i);
                    if (left.IsNull != null && left.IsNull[leftIndex]) continue;
                    if (right.IsNull != null && right.IsNull[rightIndex]) continue;
                    if (leftArray[leftIndex] == rightArray[rightIndex]) result.Add(i);
                }
            }
            else if (left.Selector.Indices != null || right.Selector.Indices != null)
            {
                // Slow Path: Look up indices on both sides. ~55ms for 16M
                for (int i = 0; i < left.Count; ++i)
                {
                    if (leftArray[left.Index(i)] == rightArray[right.Index(i)]) result.Add(i);
                }
            }
            else if (!right.Selector.IsSingleValue)
            {
                // Faster Path: Compare contiguous arrays. ~20ms for 16M
                if(s_WhereNative != null)
                {
                    s_WhereNative(leftArray, left.Selector.StartIndexInclusive, (byte)CompareOperator.Equal, rightArray, right.Selector.StartIndexInclusive, left.Selector.Count, (byte)BooleanOperator.Or, result.Vector.Array, 0);
                    return;
                }

                int zeroOffset = left.Selector.StartIndexInclusive;
                int leftIndexToRightIndex = right.Selector.StartIndexInclusive - left.Selector.StartIndexInclusive;
                for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                {
                    if (leftArray[i] == rightArray[i + leftIndexToRightIndex]) result.Add(i - zeroOffset);
                }
            }
            else if (!left.Selector.IsSingleValue)
            {
                // Fastest Path: Contiguous Array to constant. ~15ms for 16M
                int zeroOffset = left.Selector.StartIndexInclusive;
                long rightValue = rightArray[0];

                if (s_WhereSingleNative != null)
                {
                    s_WhereSingleNative(leftArray, left.Selector.StartIndexInclusive, left.Selector.Count, (byte)CompareOperator.Equal, rightValue, (byte)BooleanOperator.Or, result.Vector.Array, 0);
                    return;
                }

                for (int i = left.Selector.StartIndexInclusive; i < left.Selector.EndIndexExclusive; ++i)
                {
                    if (leftArray[i] == rightValue) result.Add(i - zeroOffset);
                }
            }
            else
            {
                // Single Static comparison. ~0.7ms for 16M [called every 10,240 rows]
                if (leftArray[left.Selector.StartIndexInclusive] == rightArray[right.Selector.StartIndexInclusive])
                {
                    result.All(left.Count);
                }
            }
        }
";

        public static void GenerateAll(string outputPath)
        {
            Directory.CreateDirectory(outputPath);

            Generate("byte", outputPath);
            Generate("sbyte", outputPath);
            Generate("ushort", outputPath);
            Generate("short", outputPath);
            Generate("int", outputPath);
            Generate("uint", outputPath);
            Generate("long", outputPath);
            Generate("ulong", outputPath);
            Generate("float", outputPath);
            Generate("double", outputPath);

            Generate("Comparable", outputPath);
        }

        public static void Generate(string typeName, string outputPath)
        {
            string className = Char.ToUpperInvariant(typeName[0]) + typeName.Substring(1) + "Comparer";

            using (var writer = new StreamWriter(File.Open(Path.Combine(outputPath, $"{className}.cs"), FileMode.Create)))
            {
                string prefix  = FilePrefix
                    .Replace("long", typeName)
                    .Replace("LongComparer", className);

                // For 'ComparableComparer', use 'T' as the type except in the class and file name.
                if (typeName == "Comparable")
                {
                    typeName = "T";
                    prefix = prefix
                        .Replace("ComparableComparer : IDataBatchComparer", "ComparableComparer<T> : IDataBatchComparer where T : System.IComparable<T>")
                        .Replace("<Comparable>", "<T>");
                }

                writer.Write(prefix);

                WriteMethod(writer, typeName, "Equal", "==");
                WriteMethod(writer, typeName, "NotEqual", "!=");
                WriteMethod(writer, typeName, "LessThan", "<");
                WriteMethod(writer, typeName, "LessThanOrEqual", "<=");
                WriteMethod(writer, typeName, "GreaterThan", ">");
                WriteMethod(writer, typeName, "GreaterThanOrEqual", ">=");

                writer.Write(FileSuffix);
            }
        }

        private static void WriteMethod(StreamWriter writer, string typeName, string operatorName, string operatorCode)
        {
            string methodBody;

            if (typeName == "T")
            {
                methodBody = CompareMethodTemplate
                    .Replace("long", typeName)
                    .Replace("Equal", operatorName);

                methodBody = Regex.Replace(methodBody, " == (?<right>(rightValue|rightArray\\[[^\\]]+\\]))", ".CompareTo(${right}) " + operatorCode + " 0");
            }
            else
            { 
                methodBody = CompareMethodTemplate
                    .Replace("long", typeName)
                    .Replace("Equal", operatorName)
                    .Replace("==", operatorCode);
            }

            writer.Write(methodBody);
        }
    }
}